//! Generates a static array of songs from the library CSV, a C-library for testing against, and the unit tests that compare library and our evaluation.
//!
//! The songs are `include!`'d as a static array into main.
//!
//! Unfortunately, the test code and C-library are always generated -- I couldn't find a way to make a 'build dev' dependency, so to speak.
//! Known limitation: https://github.com/rust-lang/cargo/issues/1581
//! This slows compilation down, but it shouldn't affect the release binary.
//!
//! Songs are copyright their respective owners.
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::Path;

fn main() {
    println!("cargo::rerun-if-changed=library.csv");
    println!("cargo::rerun-if-changed=codegen_templates/generate_references.c");

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let csv_path = Path::new(&manifest_dir).join("library.csv");
    let out_dir = env::var("OUT_DIR").unwrap();

    let file = File::open(&csv_path).expect("Failed to open library.csv");
    let reader = BufReader::new(file);

    let mut songs = Vec::new();

    for (line_num, line) in reader.lines().enumerate() {
        let line = line.expect("Failed to read line");
        if line_num == 0 {
            // Skip header
            continue;
        }
        if line.trim().is_empty() {
            continue;
        }

        if let Some((author, name, description, code)) = parse_csv_line(&line) {
            songs.push((author, name, description, code));
        }
    }

    generate_library_array(&songs, &out_dir);

    build_parity_library(&songs, &out_dir, &manifest_dir);

    generate_parity_tests(&songs, &out_dir);
}

/// P.S: This is AI slop. It works so I don't touch it.
fn parse_csv_line(line: &str) -> Option<(String, String, String, String)> {
    // Simple CSV parser that handles quoted fields with escaped quotes
    let mut fields = Vec::new();
    let mut current = String::new();
    let mut in_quotes = false;
    let mut chars = line.chars().peekable();

    while let Some(c) = chars.next() {
        if in_quotes {
            if c == '"' {
                if chars.peek() == Some(&'"') {
                    // Escaped quote
                    current.push('"');
                    chars.next();
                } else {
                    // End of quoted field
                    in_quotes = false;
                }
            } else {
                current.push(c);
            }
        } else {
            match c {
                '"' => in_quotes = true,
                ',' => {
                    fields.push(current.clone());
                    current.clear();
                }
                _ => current.push(c),
            }
        }
    }
    fields.push(current);

    if fields.len() >= 4 {
        Some((
            fields[0].clone(),
            fields[1].clone(),
            fields[2].clone(),
            fields[3..].join(","), // Join remaining fields in case code contains commas
        ))
    } else {
        None
    }
}

fn escape_raw_string(s: &str) -> String {
    // Raw strings can't contain the closing delimiter, so we replace problematic sequences
    s.replace("\"#", "\"##HASH##")
}

fn build_parity_library(
    songs: &[(String, String, String, String)],
    out_dir: &str,
    manifest_dir: &str,
) {
    let template_path = Path::new(manifest_dir).join("codegen_templates/generate_references.c");
    let out_path = Path::new(out_dir).join("generate_references.c");

    let template = fs::read_to_string(template_path).expect("Failed to read C template");
    let mut out_buf =
        BufWriter::new(File::create(&out_path).expect("Failed to create generate_references.c"));

    writeln!(
        out_buf,
        "// THIS FILE IS AUTO-GENERATED BY build.rs - DO NOT EDIT"
    )
    .unwrap();
    writeln!(out_buf).unwrap();
    write!(out_buf, "{}", template).unwrap();
    writeln!(out_buf).unwrap();

    // Generate a function for each song
    for (idx, (_author, _name, _description, code)) in songs.iter().enumerate() {
        writeln!(
            out_buf,
            "uint8_t song_{}(int32_t t) {{ return {}; }}",
            idx, code
        )
        .unwrap();
    }

    writeln!(out_buf).unwrap();

    // Generate the jump table array definition
    writeln!(out_buf, "beat_function *songs[] = {{").unwrap();
    for idx in 0..songs.len() {
        writeln!(out_buf, "    song_{},", idx).unwrap();
    }
    writeln!(out_buf, "}};").unwrap();
    writeln!(out_buf).unwrap();
    out_buf.flush().unwrap();

    cc::Build::new()
        .file(out_path)
        .warnings(false)
        .compile("parity_dispatcher");
}

fn generate_library_array(songs: &[(String, String, String, String)], out_dir: &str) {
    let out_path = Path::new(out_dir).join("library_data.rs");

    let mut out_buf =
        BufWriter::new(File::create(out_path).expect("Failed to create library_data.rs"));

    writeln!(
        out_buf,
        "// THIS FILE IS AUTO-GENERATED BY build.rs - DO NOT EDIT"
    )
    .unwrap();
    writeln!(out_buf).unwrap();
    writeln!(
        out_buf,
        "/// Included songs are copyright their respective owners."
    )
    .unwrap();
    writeln!(out_buf, "pub const SONGS: &[Song] = &[").unwrap();

    for (author, name, description, code) in songs {
        writeln!(
            out_buf,
            "    Song {{ author: r#\"{}\"#, name: r#\"{}\"#, description: r#\"{}\"#, code: r#\"{}\"# }},",
            escape_raw_string(author),
            escape_raw_string(name),
            escape_raw_string(description),
            escape_raw_string(code)
        ).unwrap();
    }

    writeln!(out_buf, "];").unwrap();
    out_buf.flush().unwrap();
}

fn generate_parity_tests(songs: &[(String, String, String, String)], out_dir: &str) {
    // The 'stub' is in the sourcecode so no template is needed
    let out_path = Path::new(out_dir).join("parity_tests.rs");
    let mut out_buf =
        BufWriter::new(File::create(out_path).expect("Failed to create parity_tests.rs"));

    writeln!(
        out_buf,
        "// THIS FILE IS AUTO-GENERATED BY build.rs - DO NOT EDIT"
    )
    .unwrap();
    writeln!(out_buf).unwrap();
    for (idx, (author, name, _description, code)) in songs.iter().enumerate() {
        // Make a snake_case test name from author and song name
        let author_part = sanitize_identifier(author);
        let name_part = sanitize_identifier(name);
        let parts: Vec<&str> = [author_part.as_str(), name_part.as_str()]
            .into_iter()
            .filter(|s| !s.is_empty())
            .collect();
        let test_name = format!("parity_{:04}_{}", idx, parts.join("_"));

        writeln!(out_buf).unwrap();
        writeln!(out_buf, "#[allow(non_snake_case)]").unwrap();
        writeln!(out_buf, "#[test]").unwrap();
        writeln!(out_buf, "fn {}() {{", test_name).unwrap();
        writeln!(out_buf, "    let song_idx = {};", idx).unwrap();
        writeln!(
            out_buf,
            "    let code = r#\"{}\"#;",
            escape_raw_string(code)
        )
        .unwrap();
        writeln!(out_buf, "    compare_song(song_idx as i32, code);").unwrap();
        writeln!(out_buf, "}}").unwrap();
    }

    out_buf.flush().unwrap();
}

/// Also slopped. Ensures the generated user tests can have useful & safe names
fn sanitize_identifier(s: &str) -> String {
    let mut result: String = s
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect();

    // Collapse consecutive underscores
    while result.contains("__") {
        result = result.replace("__", "_");
    }

    result.trim_matches('_').to_string()
}
