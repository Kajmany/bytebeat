//! Generates src/library_data.rs from library.csv at build time
//!
//! Very simple slopped nonsense. You don't have to read it because it works*
//! Included songs are copyright their respective owners.
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader};
use std::path::Path;

fn main() {
    println!("cargo::rerun-if-changed=library.csv");

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let csv_path = Path::new(&manifest_dir).join("library.csv");
    let out_path = Path::new(&manifest_dir).join("src/library_data.rs");

    let file = File::open(&csv_path).expect("Failed to open library.csv");
    let reader = BufReader::new(file);

    let mut songs = Vec::new();

    for (line_num, line) in reader.lines().enumerate() {
        let line = line.expect("Failed to read line");
        if line_num == 0 {
            // Skip header
            continue;
        }
        if line.trim().is_empty() {
            continue;
        }

        if let Some((author, name, description, code)) = parse_csv_line(&line) {
            songs.push((author, name, description, code));
        }
    }

    let mut output = String::new();
    output.push_str("//! THIS FILE IS AUTO-GENERATED BY build.rs - DO NOT EDIT\n");
    output.push_str("//!\n");
    output.push_str("//! Included songs are copyright their respective owners.\n\n");
    output.push_str("#[derive(Debug, Clone, Copy)]\n");
    output.push_str("pub struct Song {\n");
    output.push_str("    pub author: &'static str,\n");
    output.push_str("    pub name: &'static str,\n");
    output.push_str("    pub description: &'static str,\n");
    output.push_str("    pub code: &'static str,\n");
    output.push_str("}\n\n");
    output.push_str(&format!("pub const SONGS: &[Song] = &[\n"));

    for (author, name, description, code) in &songs {
        output.push_str(&format!(
            "    Song {{ author: r#\"{}\"#, name: r#\"{}\"#, description: r#\"{}\"#, code: r#\"{}\"# }},\n",
            escape_raw_string(author),
            escape_raw_string(name),
            escape_raw_string(description),
            escape_raw_string(code)
        ));
    }

    output.push_str("];\n");

    fs::write(&out_path, output).expect("Failed to write library_data.rs");
}

fn parse_csv_line(line: &str) -> Option<(String, String, String, String)> {
    // Simple CSV parser that handles quoted fields with escaped quotes
    let mut fields = Vec::new();
    let mut current = String::new();
    let mut in_quotes = false;
    let mut chars = line.chars().peekable();

    while let Some(c) = chars.next() {
        if in_quotes {
            if c == '"' {
                if chars.peek() == Some(&'"') {
                    // Escaped quote
                    current.push('"');
                    chars.next();
                } else {
                    // End of quoted field
                    in_quotes = false;
                }
            } else {
                current.push(c);
            }
        } else {
            match c {
                '"' => in_quotes = true,
                ',' => {
                    fields.push(current.clone());
                    current.clear();
                }
                _ => current.push(c),
            }
        }
    }
    fields.push(current);

    if fields.len() >= 4 {
        Some((
            fields[0].clone(),
            fields[1].clone(),
            fields[2].clone(),
            fields[3..].join(","), // Join remaining fields in case code contains commas
        ))
    } else {
        None
    }
}

fn escape_raw_string(s: &str) -> String {
    // Raw strings can't contain the closing delimiter, so we replace problematic sequences
    s.replace("\"#", "\"##HASH##")
}
