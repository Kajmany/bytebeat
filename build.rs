//! Generates library_data.rs from library.csv at build time. The songs are then `include!`'d as a static array into main.
//!
//! Songs are copyright their respective owners.
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::Path;

fn main() {
    println!("cargo::rerun-if-changed=library.csv");
    println!("cargo::rerun-if-changed=codegen_templates/library_data.rs");

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let csv_path = Path::new(&manifest_dir).join("library.csv");
    let out_dir = env::var("OUT_DIR").unwrap();

    let file = File::open(&csv_path).expect("Failed to open library.csv");
    let reader = BufReader::new(file);

    let mut songs = Vec::new();

    for (line_num, line) in reader.lines().enumerate() {
        let line = line.expect("Failed to read line");
        if line_num == 0 {
            // Skip header
            continue;
        }
        if line.trim().is_empty() {
            continue;
        }

        if let Some((author, name, description, code)) = parse_csv_line(&line) {
            songs.push((author, name, description, code));
        }
    }

    generate_library_array(&songs, &out_dir, &manifest_dir);
}

fn parse_csv_line(line: &str) -> Option<(String, String, String, String)> {
    // Simple CSV parser that handles quoted fields with escaped quotes
    let mut fields = Vec::new();
    let mut current = String::new();
    let mut in_quotes = false;
    let mut chars = line.chars().peekable();

    while let Some(c) = chars.next() {
        if in_quotes {
            if c == '"' {
                if chars.peek() == Some(&'"') {
                    // Escaped quote
                    current.push('"');
                    chars.next();
                } else {
                    // End of quoted field
                    in_quotes = false;
                }
            } else {
                current.push(c);
            }
        } else {
            match c {
                '"' => in_quotes = true,
                ',' => {
                    fields.push(current.clone());
                    current.clear();
                }
                _ => current.push(c),
            }
        }
    }
    fields.push(current);

    if fields.len() >= 4 {
        Some((
            fields[0].clone(),
            fields[1].clone(),
            fields[2].clone(),
            fields[3..].join(","), // Join remaining fields in case code contains commas
        ))
    } else {
        None
    }
}

fn escape_raw_string(s: &str) -> String {
    // Raw strings can't contain the closing delimiter, so we replace problematic sequences
    s.replace("\"#", "\"##HASH##")
}

fn generate_library_array(
    songs: &[(String, String, String, String)],
    out_dir: &str,
    manifest_dir: &str,
) {
    let template_path = Path::new(manifest_dir).join("codegen_templates/library_data.rs");
    let out_path = Path::new(out_dir).join("library_data.rs");

    let template = fs::read_to_string(template_path).expect("Failed to read template");
    let mut out_buf =
        BufWriter::new(File::create(out_path).expect("Failed to create library_data.rs"));

    writeln!(
        out_buf,
        "// THIS FILE IS AUTO-GENERATED BY build.rs - DO NOT EDIT"
    )
    .unwrap();
    writeln!(out_buf).unwrap();
    write!(out_buf, "{}", template).unwrap();

    writeln!(out_buf, "pub const SONGS: &[Song] = &[").unwrap();

    for (author, name, description, code) in songs {
        writeln!(
            out_buf,
            "    Song {{ author: r#\"{}\"#, name: r#\"{}\"#, description: r#\"{}\"#, code: r#\"{}\"# }},",
            escape_raw_string(author),
            escape_raw_string(name),
            escape_raw_string(description),
            escape_raw_string(code)
        ).unwrap();
    }

    writeln!(out_buf, "];").unwrap();
    out_buf.flush().unwrap();
}
